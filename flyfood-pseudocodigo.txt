definir ler_matriz_flyfood():
    
    dimensoes_da_matriz = entrada
    numero_de_linhas = ao inteiro da dimensoes_da_matriz[0]

    matriz = []
    
    para _ no alcance de numero_de_linhas:
        linha_da_matriz = entrada
        adicionar à matriz: linha_da_matriz
    retorne matriz

definir encontrar_pontos(matriz):
    
    pontos = {}
    numero_de_linhas = tamanho da matriz
    
    se numero_de_linhas == 0, então:
        retorne pontos
    numero_de_colunas = tamanho da matriz[0]

    para i no alcance de numero_de_linhas:
        para j no alcance de numero_de_colunas:
            valor = matriz[i][j]
            se valor != "0":
                pontos[valor] = (i, j)
    retorne pontos

definir distancia_manhattan(p1, p2):
    
    diferenca_entre_as_linhas = p1[0] - p2[0]
    se diferenca_entre_as_linhas < 0, então:
        diferenca_absoluta_de_linhas = -diferenca_entre_as_linhas
    se não, então:
        diferenca_absoluta_de_linhas = diferenca_entre_as_linhas

    diferenca_entre_as_colunas = p1[1] - p2[1]
    se diferenca_entre_as_colunas < 0, então:
        diferenca_absoluta_de_colunas = -diferenca_entre_as_colunas
    se não, então:
        diferenca_absoluta_de_colunas = diferenca_entre_as_colunas

    retorne diferenca_absoluta_de_linhas + diferenca_absoluta_de_colunas


definir gerar_permutacoes(lista):
    se tamanho de lista == 0, então:
        retorne lista contendo lista vazia
    se tamanho de lista == 1, então:
        retorne lista contendo cópia de lista

    todas_as_permutacões = []
    
    para i no alcance de tamanho de lista:
        elemento_atual = lista[i]
        lista_restante = []
        
        para j no alcance de tamanho de lista:
            se j != i, então:
                adicionar à lista_restante: lista[j]
        permutações_dos_restantes = gerar_permutacoes(lista_restante)
        para cada perm em permutações_dos_restantes:
            nova_permutação = [elemento_atual]
            para cada item em perm:
                adicionar à nova_permutação: item
            adicionar à todas_as_permutacões: nova_permutação
    
    retorne todas_as_permutacões

definir resolver_flyfood_forca_bruta():
    matriz = ler_matriz_flyfood()
    coordenadas = encontrar_pontos(matriz)
    
    se 'R' não está em coordenadas, então:
        retorne "Ponto R não encontrado"
   
    origem = coordenadas['R']

    pontos_entrega = []
    
    para cada nome em chaves de coordenadas:
        se nome != 'R', então:
            adicionar à pontos_entrega: nome
    
    se tamanho de pontos_entrega == 0, então:
        retorne ""

    rotas = gerar_permutacoes(pontos_entrega)
    menor_custo = infinito
    melhor_rota = []

    para cada rota em rotas:
        custo_atual = 0
        ponto_anterior = origem
        
        para cada nome_ponto em rota:
            ponto_atual = coordenadas[nome_ponto]
            custo_atual = custo_atual + distancia_manhattan(ponto_anterior, ponto_atual)
            ponto_anterior = ponto_atual
        
        custo_atual = custo_atual + distancia_manhattan(ponto_anterior, origem)
        
        se custo_atual < menor_custo, então:
            menor_custo = custo_atual
            melhor_rota = rota

    se encontrou melhor_rota 
        resultado_str = concatenar elementos de melhor_rota separados por espaço
        retorne resultado_str

// bloco principal

se programa principal, então:
    rota = resolver_flyfood_forca_bruta()
    imprimir rota
